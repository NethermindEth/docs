"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[438],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=r,u=p["".concat(l,".").concat(m)]||p[m]||h[m]||o;return n?a.createElement(u,i(i({ref:t},c),{},{components:n})):a.createElement(u,i({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2754:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const o={title:"Sync",sidebar_position:2},i=void 0,s={unversionedId:"fundamentals/sync",id:"fundamentals/sync",title:"Sync",description:"There are three main synchronization modes",source:"@site/docs/fundamentals/sync.md",sourceDirName:"fundamentals",slug:"/fundamentals/sync",permalink:"/docs/fundamentals/sync",draft:!1,editUrl:"https://github.com/NethermindEth/docs/tree/main/docs/docs/fundamentals/sync.md",tags:[],version:"current",lastUpdatedAt:1695150269,formattedLastUpdatedAt:"Sep 19, 2023",sidebarPosition:2,frontMatter:{title:"Sync",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Configuration",permalink:"/docs/fundamentals/configuration"},next:{title:"Security",permalink:"/docs/fundamentals/security"}},l={},d=[{value:"There are three main synchronization modes",id:"there-are-three-main-synchronization-modes",level:2},{value:"Snap Sync",id:"snap-sync",level:2},{value:"How to Enable",id:"how-to-enable",level:4},{value:"Snap Sync vs Other Sync Modes",id:"snap-sync-vs-other-sync-modes",level:4},{value:"Current limitations and future development",id:"current-limitations-and-future-development",level:4},{value:"Fast Sync",id:"fast-sync",level:2},{value:"Archive Sync",id:"archive-sync",level:2},{value:"Resync a node from scratch",id:"resync-a-node-from-scratch",level:2},{value:"Steps to Resync a Nethermind Node",id:"steps-to-resync-a-nethermind-node",level:3}],c={toc:d},p="wrapper";function h(e){let{components:t,...o}=e;return(0,r.kt)(p,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"there-are-three-main-synchronization-modes"},"There are three main synchronization modes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"snap sync",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the fastest way to sync to the network (syncs to mainnet in ","~","3 hours)"),(0,r.kt)("li",{parentName:"ul"},"downloads only the latest state, headers, and optionally bodies and receipts"))),(0,r.kt)("li",{parentName:"ul"},"fast sync",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"slower than snap sync"),(0,r.kt)("li",{parentName:"ul"},"useful on nethermind-only chains (like Gnosis), where snap sync is not available for now"),(0,r.kt)("li",{parentName:"ul"},"downloads only the latest state, headers, and optionally bodies and receipts"))),(0,r.kt)("li",{parentName:"ul"},"archive sync",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"heavy historical sync verifying all the transactions and keeping all the historical state"),(0,r.kt)("li",{parentName:"ul"},"you can run it like this ",(0,r.kt)("inlineCode",{parentName:"li"},"./Nethermind.Runner --config mainnet_archive"))))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Sync Mode"),(0,r.kt)("th",{parentName:"tr",align:null},"Disk Space needed"),(0,r.kt)("th",{parentName:"tr",align:null},"Full current state"),(0,r.kt)("th",{parentName:"tr",align:null},"Full current and all historical states"),(0,r.kt)("th",{parentName:"tr",align:null},"Can sync a full archive node from this"),(0,r.kt)("th",{parentName:"tr",align:null},"Time to sync"),(0,r.kt)("th",{parentName:"tr",align:null},"Time to RPC"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"archive"),(0,r.kt)("td",{parentName:"tr",align:null},"~","12TB"),(0,r.kt)("td",{parentName:"tr",align:null},"YES"),(0,r.kt)("td",{parentName:"tr",align:null},"YES"),(0,r.kt)("td",{parentName:"tr",align:null},"YES"),(0,r.kt)("td",{parentName:"tr",align:null},"~","3 weeks"),(0,r.kt)("td",{parentName:"tr",align:null},"~","3 weeks")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"snap/fast sync with all bodies and receipts"),(0,r.kt)("td",{parentName:"tr",align:null},"~","800GB"),(0,r.kt)("td",{parentName:"tr",align:null},"YES"),(0,r.kt)("td",{parentName:"tr",align:null},"NO"),(0,r.kt)("td",{parentName:"tr",align:null},"YES"),(0,r.kt)("td",{parentName:"tr",align:null},"~","20 hours"),(0,r.kt)("td",{parentName:"tr",align:null},"~","20 hours")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"default snap/fast sync (with barriers set to support Eth2)"),(0,r.kt)("td",{parentName:"tr",align:null},"~","500GB"),(0,r.kt)("td",{parentName:"tr",align:null},"YES"),(0,r.kt)("td",{parentName:"tr",align:null},"NO"),(0,r.kt)("td",{parentName:"tr",align:null},"NO"),(0,r.kt)("td",{parentName:"tr",align:null},"~","11 hours"),(0,r.kt)("td",{parentName:"tr",align:null},"~","11 hours")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"snap/fast sync without receipts"),(0,r.kt)("td",{parentName:"tr",align:null},"~","450GB"),(0,r.kt)("td",{parentName:"tr",align:null},"YES"),(0,r.kt)("td",{parentName:"tr",align:null},"NO"),(0,r.kt)("td",{parentName:"tr",align:null},"YES"),(0,r.kt)("td",{parentName:"tr",align:null},"~","12 hours"),(0,r.kt)("td",{parentName:"tr",align:null},"~","12 hours")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"snap/fast sync without bodies and receipts"),(0,r.kt)("td",{parentName:"tr",align:null},"~","200GB"),(0,r.kt)("td",{parentName:"tr",align:null},"YES"),(0,r.kt)("td",{parentName:"tr",align:null},"NO"),(0,r.kt)("td",{parentName:"tr",align:null},"NO"),(0,r.kt)("td",{parentName:"tr",align:null},"~","9 hours"),(0,r.kt)("td",{parentName:"tr",align:null},"~","9 hours")))),(0,r.kt)("h2",{id:"snap-sync"},"Snap Sync"),(0,r.kt)("p",null,"Snap sync allows a node to perform the initial synchronization and download of Ethereum\u2019s state up to 10 times faster\nthan using fast sync."),(0,r.kt)("h4",{id:"how-to-enable"},"How to Enable"),(0,r.kt)("p",null,"Snap sync is enabled by default for majority of networks. To make sure, check if",(0,r.kt)("inlineCode",{parentName:"p"},"SnapSync")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," in the Sync\nmodule of your ",(0,r.kt)("inlineCode",{parentName:"p"},".cfg")," file"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'"Sync": {\n    "SnapSync": true\n}\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"IMPORTANT"),": Do not enable snap sync on a previously synced node. Only use when syncing to the network for the first\ntime."),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"IMPORTANT"),": Do not remove other configurations from Sync module. Just add ",(0,r.kt)("inlineCode",{parentName:"p"},'"SnapSync": true'),", e.g."),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre"},'"Sync": {\n    "SnapSync": true,\n    "PivotNumber": 15011000,\n        "PivotHash": "0x46c838d02d5fa5bc070080ed7965da1d888f6eb1797045365407c7011280af56",\n        "PivotTotalDifficulty": "52367203434576253689712",\n        "FastBlocks": true\n}\n'))),(0,r.kt)("h4",{id:"snap-sync-vs-other-sync-modes"},"Snap Sync vs Other Sync Modes"),(0,r.kt)("p",null,"More than 12TB of storage is needed today to run a full archive node \u2014 one that stores all the state since genesis.\nBecause of that, setting up an archive node can take days or even weeks. Fast Sync can still take more than 24 hours on\nthe fast machine and download about 90GB state data. With Snap Sync, sync time is reduced to 2-3h with a download of\nabout 30GB."),(0,r.kt)("p",null,"This reduction in sync time and download size has to do with the specific way in which Ethereum\u2019s state is stored in a\nnode: Merkle trees."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(3192).Z,width:"1168",height:"939"})),(0,r.kt)("p",null,"With Fast Sync, a node downloads the headers of each block and retrieves all the nodes beneath it until it reaches the\nleaves. By contrast, Snap Sync only downloads the leaf nodes, generating the remaining nodes locally which saves time\nand packets downloaded."),(0,r.kt)("h4",{id:"current-limitations-and-future-development"},"Current limitations and future development"),(0,r.kt)("p",null,"For now Snap Sync on the Nethermind client can only download the Ethereum state but not serve it to other clients - snap\nserving development is in progress, expected late 2023/early 2024."),(0,r.kt)("p",null,"The only Ethereum client that supports serving Snap Sync requests is Geth, so only networks supported by Geth can be\nsynced using that method: Mainnet, Goerli, Sepolia."),(0,r.kt)("h2",{id:"fast-sync"},"Fast Sync"),(0,r.kt)("p",null,"After completing the fast sync your node will have the ability to answer questions like ",(0,r.kt)("em",{parentName:"p"},"'what is my account\nbalance ",(0,r.kt)("strong",{parentName:"em"},"now"),"'"),", ",(0,r.kt)("em",{parentName:"p"},"'how many XYZ tokens SomeExchange holds ",(0,r.kt)("strong",{parentName:"em"},"at the moment"),"'"),"."),(0,r.kt)("p",null,"Fast sync has multiple stages. Nethermind uses a ",(0,r.kt)("inlineCode",{parentName:"p"},"pivot block")," number to improve fast sync performance.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"pivot block")," data is automatically updated after initialization of the client and consists of\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"block number"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"block hash")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"block total difficulty")," (please note that ",(0,r.kt)("inlineCode",{parentName:"p"},"total difficulty")," is different\nthan ",(0,r.kt)("inlineCode",{parentName:"p"},"difficulty"),"). Before synchronizing state data Nethermind synchronizes in two directions - backwards\nfrom ",(0,r.kt)("inlineCode",{parentName:"p"},"pivot block")," to 0 for headers and forward to the head of the chain for headers, blocks and receipts. Forward sync\nmight be very slow (5 - 50 bps) so having fresh pivot block is very important - it is guaranteed by recently implemented\nauto-update."),(0,r.kt)("p",null,"After downloading the block data Nethermind will start state sync (downloading the latest state trie nodes). We are\nproviding an estimate for the download size and progress but the real value may be different than the estimate (\nespecially if you are using an old version of Nethermind as we sometimes manually adjust the estimator based on our\nobservations of the chain growth rate). Because of this sometimes your sync may continue even when it shows ","~","100%\nfinished. The other important component is the speed of your sync - if your IO / network / file system causes the state\nsync to go much slower than around 1.5MB per second on average then you will start downloading some parts of the trie\nover and over again. In such cases you may be surprised to see something like 58000MB / 53000MB (100%). It means that\nyou downloaded around 5GB of data that is no longer needed. If your sync is very slow (extended beyond two days) then\nvery likely your setup cannot catch up with the chain progress."),(0,r.kt)("p",null,"After the state sync finishes you will see the ",(0,r.kt)("em",{parentName:"p"},"'Processed...'")," messages like in archive sync - it means that your node\nis in sync and is processing the latest blocks."),(0,r.kt)("p",null,"Mainnet sync, at the time of writing (December 2020), takes around 8 hours on an UpCloud 16GB RAM 8 CPU $40 VM (and then\nsyncs receipts and bodies in the background if you enabled them in the configuration). Goerli sync should take around 40\nminutes."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Fast sync logs example for mainnet.",src:n(4705).Z,width:"1920",height:"1030"})),(0,r.kt)("p",null,"State sync log messages have multiple values displayed. First ",(0,r.kt)("inlineCode",{parentName:"p"},"dd.HH:mm:ss")," total state sync time is displayed, followed\nby an estimated sync progress (percentage of total database data synced), then the current download speed is displayed (\nthere will be times when it will slow down to 0 or single digit numbers, especially towards the end of the sync). In\ngeneral 6 hours sync times shown on screenshots are with around 2000 kB/s (kilobytes per second) average sync rate. You\ncan calculate it in the example as ","~","45GB / (2MB/s) ","~"," 22500 seconds ","~","6.25 hours. We also display the number of state\naccounts synced, number of trie nodes synced and a diagnostic message in the format of ",(0,r.kt)("em",{parentName:"p"},"[","number","_","of","_","pending","_","requests]\n.","[","average time spent in response handler displayed as milliseconds]"),". So ",(0,r.kt)("inlineCode",{parentName:"p"},"5.6.20ms")," means that we are awaiting for\nresponses to 5 requests that have been sent to peers and the average time it takes us to process a single response is\n6.20ms. The response handling times will differ depending on how many trie nodes are already cached (so they will be\nsignificantly slower for a while after the node restart when cache has to be rebuilt) and based on how fast the database\nIO is (SSD vs NVMe vs cloud drives). For a reasonable sync time you probably should expect these values to be below\n15ms (but they may be as high as 700ms for a while after restarting the node)."),(0,r.kt)("p",null,"A single restart of the node during the fast sync may extend the sync time by up to two hours because the node has to\nrebuild the caches by reading millions of values from the database."),(0,r.kt)("p",null,"At the last stages of the sync the node will be repeatedly displaying the branch sync progress and changing the block\nnumber to which it tries to catch up. This stage should take between 30 minutes and two hours. If it lasts much more\nthen it is possible that you will not be able to catch up with the network progress."),(0,r.kt)("p",null,"One of the best indicators that you are close to be synced is combined ","~","100% state size progress and nearly 100% branch\nsync progress."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(8950).Z,width:"1920",height:"1030"})),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(2794).Z,width:"1895",height:"795"})),(0,r.kt)("h2",{id:"archive-sync"},"Archive Sync"),(0,r.kt)("p",null,"Archive sync is the 'heaviest' and slowest sync mode but allows to ask questions like ",(0,r.kt)("em",{parentName:"p"},"'what was the balance of my\naccount 2 years ago?'"),", ",(0,r.kt)("em",{parentName:"p"},"'how many XYZ token were held in SomeExchange custody in 2017?'"),"."),(0,r.kt)("p",null,"We have prepared default archive sync configurations and they can be launched from Nethermind Launcher (just choose the\narchive options) or by simply loading appropriate config when launching ",(0,r.kt)("inlineCode",{parentName:"p"},"./Nethermind.Runner --config mainnet_archive")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"./Nethermind.Runner --config goerli_archive")),(0,r.kt)("p",null,"While for some smaller networks archive sync can complete very quickly (in minutes or hours) mainnet sync would take 2 -\n6 weeks depending on the speed of your IO (whether you use SSD or NVMe or depending on the cloud provider IOPS).\nDatabase size in archive sync is the biggest from all modes as you will store all the historical data."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Example of the archive sync logs",src:n(4690).Z,width:"1920",height:"1030"})),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(9301).Z,width:"1920",height:"1030"})),(0,r.kt)("p",null,"Explanation of some data in the logs:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"at the beginning you may see a ",(0,r.kt)("em",{parentName:"li"},"'Waiting for peers...'")," message while the node is trying to discover nodes that it can\nsync with."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"'Downloaded 1234/8000000'")," shows the number of unprocessed blocks (with transactions) downloaded from the network.\nFor ",(0,r.kt)("inlineCode",{parentName:"li"},"mainnet"),"this value may be slower than processing at first but very quickly you will see blocks being downloaded\nmuch faster than processed. Empty blocks can be as small as 512 bytes (just headers without transactions) and full\nblocks with heavy transactions can reach a few hundred kilobytes. We display both current download speed (calculated\nin the last second) and average (total) speed since starting the node."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"'Processed ...'")," displays the blocks that have been processed by the EVM. The first number shows the current head\nblock number, then you can see ",(0,r.kt)("inlineCode",{parentName:"li"},"mgasps")," (million gas per second) - current and total, then ",(0,r.kt)("inlineCode",{parentName:"li"},"tps")," (transactions per\nsecond) - current and total, ",(0,r.kt)("inlineCode",{parentName:"li"},"bps")," (blocks per second). Then ",(0,r.kt)("inlineCode",{parentName:"li"},"recv queue")," (transactions signature public key recovery\nqueue), ",(0,r.kt)("inlineCode",{parentName:"li"},"proc queue")," (processor queue). Both recovery queue and processor queue are designed so when too many blocks\nare waiting for processing then only their hashes are kept in memory and remaining data are stored in the database.\nThus, the queues numbers that you can see will be capped by some number."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"'Cache for epoch...'")," informs about ",(0,r.kt)("inlineCode",{parentName:"li"},"ethash")," cache needed for block seal verification (only on ",(0,r.kt)("inlineCode",{parentName:"li"},"mainnet"),"\nand ",(0,r.kt)("inlineCode",{parentName:"li"},"ropsten"),"). Caches will be calculated every 30000 blocks (length of an epoch) but can also be calculated for the\nlatest blocks that are being broadcast on the network."),(0,r.kt)("li",{parentName:"ul"},"After the archive sync finishes you will see the ",(0,r.kt)("em",{parentName:"li"},"'Processed...'")," message appearing on average every 15 seconds when\nthe new block is processed."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mgasps"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"tps"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"bps")," values should not be treated as comparable as they may differ massively on different parts of\nthe chain. For example when blocks are empty you may see very high ",(0,r.kt)("inlineCode",{parentName:"li"},"bps")," values with very low (or even zero) ",(0,r.kt)("inlineCode",{parentName:"li"},"tps"),"\nand ",(0,r.kt)("inlineCode",{parentName:"li"},"mgasps")," values as there are no transactions and no gas for EVM processing and blocks are very light. On the other\nhand when blocks are filled with very heavy transactions then ",(0,r.kt)("inlineCode",{parentName:"li"},"bps")," might be very low while ",(0,r.kt)("inlineCode",{parentName:"li"},"mgasps")," will be very\nhigh. It is even possible that you will see a lot of very light transactions where ",(0,r.kt)("inlineCode",{parentName:"li"},"tps")," will be high while ",(0,r.kt)("inlineCode",{parentName:"li"},"bps"),"\nand ",(0,r.kt)("inlineCode",{parentName:"li"},"mgasps")," will be average.")),(0,r.kt)("h2",{id:"resync-a-node-from-scratch"},"Resync a node from scratch"),(0,r.kt)("p",null,"This guide explains how to resync a Nethermind node using the existing Pivot block or updating it to a more recent one."),(0,r.kt)("h3",{id:"steps-to-resync-a-nethermind-node"},"Steps to Resync a Nethermind Node"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Stop the Nethermind node"),": If your Nethermind node is currently running, stop it to ensure that no new data is\nbeing written to the database during the resync process."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Delete the existing database"),": Navigate to the Nethermind data directory. The location of this directory depends\non how Nethermind was installed and your configuration settings. Inside the data directory, find the ",(0,r.kt)("inlineCode",{parentName:"li"},"nethermind_db"),"\nfolder and delete the ",(0,r.kt)("inlineCode",{parentName:"li"},"mainnet")," subfolder to remove the existing database for the mainnet."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Update the configuration file (optional)"),": If you want to change any configuration settings before resyncing the\nnode, edit the ",(0,r.kt)("inlineCode",{parentName:"li"},"mainnet.cfg")," file located in the Nethermind directory. For example, you might want to adjust the\npruning settings or specify a different network."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Update the Pivot block (optional)"),"\\",(0,r.kt)("admonition",{parentName:"li",type:"danger"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Only for versions before 1.19.0 where Auto-Pivot approach was introduced"))),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Using Etherscan"),": If you want to speed up the syncing process, you can update the Pivot block to a more recent\none. To do this, find the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync")," section in the ",(0,r.kt)("inlineCode",{parentName:"p"},"mainnet.cfg")," file and update the ",(0,r.kt)("inlineCode",{parentName:"p"},"PivotNumber")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"PivotHash"),'\nfields to match a recent "finalized" block number and its corresponding hash. You can obtain this information from\na block explorer such as ',(0,r.kt)("a",{parentName:"p",href:"https://etherscan.io/"},"Etherscan"),".\\\n\\\nUsing block number 17165278 from ",(0,r.kt)("a",{parentName:"p",href:"https://etherscan.io/block/17165278"},"Etherscan"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},' { \n     "PivotNumber": 17165278,\n     "PivotHash": "0xa665315efd923f3b11215feee09a9d3e13c5e6ee602fa19b642824682ec0a752"\n }\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Using Nethermind's GitHub"),": Alternatively, you can update the Pivot block by referring to\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/NethermindEth/nethermind/blob/master/src/Nethermind/Nethermind.Runner/configs/mainnet.cfg"},"Nethermind's mainnet.cfg file on GitHub"),".\nThe Pivot block is periodically bumped to the HEAD-8192 block of the mainnet chain. Copy the ",(0,r.kt)("inlineCode",{parentName:"p"},"PivotNumber"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"PivotHash")," values from the GitHub file and update your local ",(0,r.kt)("inlineCode",{parentName:"p"},"mainnet.cfg")," file accordingly.")))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Restart the Nethermind node"),": Start the Nethermind node again to initiate the resync process. The node will begin\nsyncing from the existing Pivot block or the specified updated Pivot block, downloading and processing all the blocks\nin the blockchain.")),(0,r.kt)("p",null,"To ensure that your Nethermind node is resyncing, you can monitor the logs for the node's progress. The logs will\ndisplay information about the block processing, synchronization status and ",(0,r.kt)("inlineCode",{parentName:"p"},"OldHeaders")," being processed. By observing\nthe increasing block numbers and synchronization messages in the logs, you can confirm that the resync process is active\nand working as expected."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Old Headers 0 / 17154000 | queue 0 | current 0.00bps | total 0.00bps"),(0,r.kt)("p",{parentName:"blockquote"},"Old Headers 768 / 17154000 | queue 0 | current 766.07bps | total 762.49bps"),(0,r.kt)("p",{parentName:"blockquote"},"Beacon Headers from block 17154001 to block 17169722 | 960 / 15722 | queue 4992 | current 0.00bps | total\n40622848.83bps"),(0,r.kt)("p",{parentName:"blockquote"},"Old Headers 9024 / 17154000 | queue 0 | current 576.40bps | total 1286.40bps"),(0,r.kt)("p",{parentName:"blockquote"},"Beacon Headers from block 17154001 to block 17169723 | 9024 / 15723 | queue 6698 | current 2694.81bps | total\n3882943.63bps\\\nDownloaded 17154031 / 17172359 | current 0.00bps | total 0.00bps"),(0,r.kt)("p",{parentName:"blockquote"},"Downloaded 17154062 / 17169724 | current 0.00bps | total 2.88bps")),(0,r.kt)("p",null,"Keep in mind that resyncing a Nethermind node can take a considerable amount of time. It depends on your hardware,\ninternet connection, and the size of the blockchain."))}h.isMDXComponent=!0},3192:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Untitled(1)-e656672bbe5916256187472154cefdbf.png"},9301:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image(57)-6779647766702b4a63d74e01bd27978a.png"},4690:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image(58)-c9384f350dfd11adec8694dbfb73b52e.png"},4705:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image(59)-e679a155889ccdf54fbff7695df20603.png"},2794:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image(62)-0a2d55653744c60e1f441c3a4996d694.png"},8950:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image(64)-08dc4f39e5c66db897d66b586c5581d0.png"}}]);