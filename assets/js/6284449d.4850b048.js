"use strict";(self.webpackChunknethermind_docs=self.webpackChunknethermind_docs||[]).push([[4168],{2913:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"fundamentals/performance-tuning","title":"Performance tuning","description":"By default, Nethermind is configured for general use cases that fit well for most users. However, to improve various aspects of Nethermind performance, there are options for different subsystems that can be configured for your specific needs.","source":"@site/versioned_docs/version-1.34.0/fundamentals/performance-tuning.md","sourceDirName":"fundamentals","slug":"/fundamentals/performance-tuning","permalink":"/fundamentals/performance-tuning","draft":false,"unlisted":false,"editUrl":"https://github.com/NethermindEth/docs/tree/main/versioned_docs/version-1.34.0/fundamentals/performance-tuning.md","tags":[],"version":"1.34.0","lastUpdatedAt":1758822180000,"sidebarPosition":7,"frontMatter":{"title":"Performance tuning","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Pruning","permalink":"/fundamentals/pruning"},"next":{"title":"Private networks","permalink":"/fundamentals/private-networks"}}');var i=t(4848),r=t(8453);const o={title:"Performance tuning",sidebar_position:7},a=void 0,c={},l=[{value:"Peer discovery",id:"peer-discovery",level:2},{value:"Port forwarding",id:"port-forwarding",level:2},{value:"Sync time",id:"sync-time",level:2},{value:"Snap sync",id:"snap-sync",level:2},{value:"Old bodies and receipts",id:"old-bodies-and-receipts",level:2},{value:"Block processing time and attestation",id:"block-processing-time-and-attestation",level:2},{value:"Memory",id:"memory",level:2},{value:"At least 32 GB",id:"at-least-32-gb",level:3},{value:"At least 128 GB",id:"at-least-128-gb",level:3},{value:"At least 350 GB",id:"at-least-350-gb",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"By default, Nethermind is configured for general use cases that fit well for most users. However, to improve various aspects of Nethermind performance, there are options for different subsystems that can be configured for your specific needs."}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"This guide uses some undocumented configuration options that are not intended for the general public and may change in future releases."})}),"\n",(0,i.jsx)(n.h2,{id:"peer-discovery",children:"Peer discovery"}),"\n",(0,i.jsxs)(n.p,{children:["To connect to the Ethereum network, Nethermind needs to maintain connections to other clients. The number of connections can be configured with ",(0,i.jsx)(n.a,{href:"/fundamentals/configuration#network-maxactivepeers",children:(0,i.jsx)(n.code,{children:"Network.MaxActivePeers"})})," configuration option. The default value depends on the network. Increasing this number may reduce syncing time, while reducing this number may help with attestation performance.\nAlso, you can increase the rate at which a new connection is established with ",(0,i.jsx)(n.code,{children:"Network.MaxOutgoingConnectPerSec"}),". The default value is 20 while 50 would be a reasonable higher value. This tends to reduce the snap sync time; however, some ISPs may throttle your Internet connection if you set this value too high. Also, some Wi-Fi routers may hang if the value is set too high."]}),"\n",(0,i.jsx)(n.h2,{id:"port-forwarding",children:"Port forwarding"}),"\n",(0,i.jsxs)(n.p,{children:["While port forwarding is not strictly required, it helps significantly with finding peers and is essential for the network's overall health. The exact steps for port forwarding highly depend on your environment, router, and ISP. For most home configurations, automatic port forwarding can be turned on with ",(0,i.jsx)(n.a,{href:"/fundamentals/configuration#network-enableupnp",children:(0,i.jsx)(n.code,{children:"Network.EnableUPnP"})}),".\nSome ISPs are more restrictive and do not support port forwarding and/or utilize provider-level NAT. In such cases, your best option is to use a VPN that supports port forwarding. Keep in mind that consensus clients need a separate port forwarding."]}),"\n",(0,i.jsx)(n.h2,{id:"sync-time",children:"Sync time"}),"\n",(0,i.jsx)(n.p,{children:"On the Ethereum mainnet, most of the syncing time is split into three phases: snap sync, old bodies, and old receipts. Strictly speaking, there are also fast sync, full sync, and state sync phases. However, they usually complete in less than a minute, with state sync usually taking up to 3 minutes."}),"\n",(0,i.jsx)(n.p,{children:"At the moment, the best test case sync time is 1 hour 50 minutes for all phases with the following configuration:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"CPU: AMD Ryzen 9 7950X"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Memory: 128GB RAM"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Storage: Intel Optane SSD 905P Series 900GB"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Network: 1 Gbps Internet with TorGuard VPN with WireGuard protocol. Both execution and consensus clients port forwarding are set up manually."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Command line options:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"--network-enableupnp\n--network-maxoutgoingconnectpersec 50\n--network-processingthreadcount 32\n--sync-tunedbmode HeavyWrite\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"snap-sync",children:"Snap sync"}),"\n",(0,i.jsx)(n.p,{children:"Snap sync is the process of downloading the Ethereum state tree. After it is complete, and after the state sync phase, Nethermind can process and follow the chain. The fastest tested snap sync and state sync time is 25 minutes.\nThis phase is the most I/O-intensive sync phase, and therefore, assuming a fast internet, the sync time highly depends on your SSD's write speed. Remember that most SSDs only advertise peak write speed, usually above 5GB/s. However, they tend to slow down significantly to around 0.5GB/s (or even less for a QLC SSD) after a few seconds. Therefore, look for SSDs with high sustained write speed."}),"\n",(0,i.jsx)(n.p,{children:"Also, ensuring your SSD is sufficiently cooled to prevent thermal throttling is essential. This is often overlooked as most workloads rarely stress SSD as much; however, to reduce sync time, Nethermind will utilize your SSD to its limit."}),"\n",(0,i.jsxs)(n.p,{children:["Nethermind temporarily changes the database configuration during sync to optimize it for writing, notably the option ",(0,i.jsx)(n.code,{children:"Sync.TuneDbMode"})," is set to ",(0,i.jsx)(n.code,{children:"HeavyWrite"})," by default. On some systems with slow SSDs, the setting the ",(0,i.jsx)(n.code,{children:"Sync.TuneDbMode"})," to ",(0,i.jsx)(n.code,{children:"AggressiveHeavyWrite"})," may give some boost. Also, the compaction can be disabled altogether by setting the ",(0,i.jsx)(n.code,{children:"Sync.TuneDbMode"})," to ",(0,i.jsx)(n.code,{children:"DisableCompaction"}),". This is likely faster for systems using entry-level NVMe SSDs and is also useful to extend the lifespan of your SSD as it provides the lowest total writes possible. However, it uses about 3GB of extra memory during snap sync. The state sync phase may appear to hang for about 10 minutes as the whole database compacts for the first time after snap sync."]}),"\n",(0,i.jsx)(n.h2,{id:"old-bodies-and-receipts",children:"Old bodies and receipts"}),"\n",(0,i.jsxs)(n.p,{children:["Old bodies and old receipts are the process of downloading block bodies and receipts. This is required for some RPC methods, such as ",(0,i.jsx)(n.code,{children:"eth_getLogs"}),", and for consensus clients to work correctly. If you don't need them, skip this phase by setting the ",(0,i.jsx)(n.a,{href:"/fundamentals/configuration#sync-downloadbodiesinfastsync",children:(0,i.jsx)(n.code,{children:"Sync.DownloadBodiesInFastSync"})})," to ",(0,i.jsx)(n.code,{children:"false"}),", ",(0,i.jsx)(n.a,{href:"/fundamentals/configuration#sync-downloadreceiptsinfastsync",children:(0,i.jsx)(n.code,{children:"Sync.DownloadReceiptsInFastSync"})})," to ",(0,i.jsx)(n.code,{children:"false"}),", and ",(0,i.jsx)(n.a,{href:"/fundamentals/configuration#sync-nonvalidatornode",children:(0,i.jsx)(n.code,{children:"Sync.NonValidatorNode"})})," to ",(0,i.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Old bodies and receipts are mainly limited by your Internet connection. With a 1Gbps connection, they consume around 250MB/s and 500MB/s of writes, respectively, which is generally reasonable for most PCIE SSDs. On older systems or VPS with low single thread performance and high Internet speed, the block body deserialization may be a bottleneck, in which case, you can increase the number of network processing threads by setting ",(0,i.jsx)(n.code,{children:"Network.ProcessingThreadCount"})," to ",(0,i.jsx)(n.code,{children:"32"}),". However, this may impact block processing time."]}),"\n",(0,i.jsx)(n.h2,{id:"block-processing-time-and-attestation",children:"Block processing time and attestation"}),"\n",(0,i.jsxs)(n.p,{children:["Block processing time is primarily limited by SSD performance. In practice, it is the SSD's ",(0,i.jsx)(n.em,{children:"response time"}),", not just its IOPS, that matters. However, since most SSDs don't advertise response times, IOPS often serves as a useful approximation."]}),"\n",(0,i.jsxs)(n.p,{children:["Nethermind includes a ",(0,i.jsx)(n.em,{children:"prewarming"})," feature\xa0that parallelizes state reads by executing transactions concurrently, warming up state reads for the main block processing. This effectively hides SSD latency, although it increases CPU usage. For non-validator nodes, where RPC throughput is more important, you can turn off this optimization by setting the ",(0,i.jsx)(n.a,{href:"/fundamentals/configuration#blocks-prewarmstateonblockprocessing",children:(0,i.jsx)(n.code,{children:"Blocks.PreWarmStateOnBlockProcessing"})})," option to ",(0,i.jsx)(n.code,{children:"false"}),". While disabling prewarming may conserve CPU resources, the benefits are typically minor."]}),"\n",(0,i.jsx)(n.h2,{id:"memory",children:"Memory"}),"\n",(0,i.jsx)(n.p,{children:"Ethereum aims to be maximally decentralized, so the default Nethermind configuration minimizes system resource usage. However, several tunable parameters are available if your system has large enough memory."}),"\n",(0,i.jsx)(n.h3,{id:"at-least-32-gb",children:"At least 32 GB"}),"\n",(0,i.jsx)(n.p,{children:"For systems with at least 32 GB of memory, the following configuration is recommended:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Pruning.CacheMb: 2000"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"/fundamentals/pruning#in-memory-cache-size",children:"pruning cache"})," increased from 1 GB to 2 GB, reducing total SSD writes by roughly a factor of 3 (note that ~500 MB of cache is retained for snap serving)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Db.StateDbWriteBufferSize: 100000000"})}),"\n",(0,i.jsx)(n.p,{children:"The write buffer size should be increased proportionally with the pruning cache to avoid extended pruning times that might block attestation."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:'Db.StateDbAdditionalRocksDbOptions: "block_based_table_factory={index_type=kBinarySearch;partition_filters=0;};"'})}),"\n",(0,i.jsx)(n.p,{children:"Changes the database index not to use the partitioned index, improving latency at the cost of ~500 MB of additional memory."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"at-least-128-gb",children:"At least 128 GB"}),"\n",(0,i.jsx)(n.p,{children:"For systems with at least 128 GB of memory, the following configuration is recommended:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Pruning.CacheMb: 4000"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"/fundamentals/pruning#in-memory-cache-size",children:"pruning cache"})," is increased to 4 GB, and the write buffer size to 200 MB."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Db.StateDbWriteBufferSize: 200000000"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:'Db.StateDbAdditionalRocksDbOptions: "block_based_table_factory={index_type=kBinarySearch;partition_filters=0;};"'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Db.StateDbEnableFileWarmer: true"})}),"\n",(0,i.jsx)(n.p,{children:"Enabling the file warmer primes the OS cache by reading the database files at startup. Without this option, the OS cache can take several weeks to warm up naturally."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"at-least-350-gb",children:"At least 350 GB"}),"\n",(0,i.jsx)(n.p,{children:"For systems with at least 350 GB of memory, where the entire state can be loaded into memory, beneficial for RPC providers, the following configuration is recommended:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Pruning.CacheMb: 4000"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"/fundamentals/pruning#in-memory-cache-size",children:"pruning cache"})," is increased to 4 GB, and the write buffer size to 200 MB."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Db.StateDbWriteBufferSize: 200000000"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:'Db.StateDbAdditionalRocksDbOptions: "block_based_table_factory={index_type=kBinarySearch;block_size=4092;block_restart_interval=2;partition_filters=0};compression=kNoCompression;allow_mmap_reads=1;"'})}),"\n",(0,i.jsx)(n.p,{children:"Turning off the database compression and using a less compact encoding increases the database size (approximately 280 GB compared to the standard 160 GB) but offers a more CPU-efficient encoding for block processing. It also enables memory-mapped (MMAP) reads, which skip RocksDB's internal block cache and the memory allocator. Note, however, that to enable MMAP verification, checksum needs to be disabled."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Db.StateDbVerifyChecksum: false"})}),"\n",(0,i.jsx)(n.p,{children:"In addition to prewarming, state access typically accounts for less than 10% of block processing time. This is notable, especially with server CPU, where the low frequency tends to result in higher block processing latency."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);