"use strict";(globalThis.webpackChunknethermind_docs=globalThis.webpackChunknethermind_docs||[]).push([[1977],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(6540);const r={},o=i.createContext(r);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}},9644:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"fundamentals/history-pruning","title":"History pruning","description":"History pruning is a feature set that aims to reduce storage space requirements for a node by removing old historical data. The goal is to remove the requirement from nodes to store all the historical data but ensure the old data is preserved and accessible for anyone who needs it. For details, see EIP-4444.","source":"@site/docs/fundamentals/history-pruning.md","sourceDirName":"fundamentals","slug":"/fundamentals/history-pruning","permalink":"/next/fundamentals/history-pruning","draft":false,"unlisted":false,"editUrl":"https://github.com/NethermindEth/docs/tree/main/docs/fundamentals/history-pruning.md","tags":[],"version":"current","lastUpdatedAt":1765915852000,"sidebarPosition":7,"frontMatter":{"title":"History pruning","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"State pruning","permalink":"/next/fundamentals/state-pruning"},"next":{"title":"Performance tuning","permalink":"/next/fundamentals/performance-tuning"}}');var r=t(4848),o=t(8453);const a={title:"History pruning",sidebar_position:7},s=void 0,l={},c=[{value:"Era1 format",id:"era1-format",level:2},{value:"Import",id:"import",level:2},{value:"Export",id:"export",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["History pruning is a feature set that aims to reduce storage space requirements for a node by removing old historical data. The goal is to remove the requirement from nodes to store all the historical data but ensure the old data is preserved and accessible for anyone who needs it. For details, see ",(0,r.jsx)(n.a,{href:"https://eips.ethereum.org/EIPS/eip-4444",children:"EIP-4444"}),"."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["History pruning is enabled by default for the networks supporting it. To disable, set ",(0,r.jsx)(n.a,{href:"/next/fundamentals/configuration#sync-ancientbodiesbarrier",children:(0,r.jsx)(n.code,{children:"Sync.AncientBodiesBarrier"})})," and ",(0,r.jsx)(n.a,{href:"/next/fundamentals/configuration#sync-ancientreceiptsbarrier",children:(0,r.jsx)(n.code,{children:"Sync.AncientReceiptsBarrier"})})," to ",(0,r.jsx)(n.code,{children:"0"}),"."]})}),"\n",(0,r.jsx)(n.h2,{id:"era1-format",children:"Era1 format"}),"\n",(0,r.jsxs)(n.p,{children:["The pre-Merge historical data is serviced in ",(0,r.jsx)(n.a,{href:"https://github.com/status-im/nimbus-eth2/blob/stable/docs/e2store.md#era-files",children:"Era1"})," format, which is an archival format initially designed for the consensus layer by Nimbus."]}),"\n",(0,r.jsx)(n.p,{children:"An Era1 archive can be expressed as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"era1 := Version | block-tuple* | other-entries* | Accumulator | BlockIndex\nblock-tuple :=  CompressedHeader | CompressedBody | CompressedReceipts | TotalDifficulty\nblock-index := starting-number | index | index | index ... | count\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Block headers, bodies, and receipts are compressed using the\xa0",(0,r.jsx)(n.a,{href:"https://github.com/google/snappy/blob/main/framing_format.txt",children:"Snappy framing format"}),". Each file contains a block index for fast lookup and an\xa0",(0,r.jsx)(n.a,{href:"https://github.com/ethereum/portal-network-specs/blob/master/history/history-network.md#the-historical-hashes-accumulator",children:"epoch accumulator"}),"\xa0for verification. The epoch accumulator can verify the entire archive with accumulators from a trusted source. It also allows a node to download a block header with a Merkle proof, proving it belongs to a particular epoch."]}),"\n",(0,r.jsx)(n.h2,{id:"import",children:"Import"}),"\n",(0,r.jsx)(n.p,{children:'Nethermind allows importing of a historical block range from a specified location to the database. During import, the block range before the head will be inserted in parallel like old bodies, and after the head will be "suggested" like forward sync. So, it will process a new imported block.'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Import will not complete until the blocks are processed and will pause adding them if the processing queue reaches 2000 blocks."}),"\n",(0,r.jsx)(n.li,{children:"An exception to this is if fast sync is enabled and the head is 0, in which case, it will only insert blocks like old bodies."}),"\n",(0,r.jsx)(n.li,{children:"Accumulator and content are always verified/checksummed."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The data can be imported using the following configuration options on Nethermind startup. Note that this is a blocking operation and puts other activities on hold until it is completed:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/next/fundamentals/configuration#era-importdirectory",children:(0,r.jsx)(n.code,{children:"Era.ImportDirectory"})})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/next/fundamentals/configuration#era-from",children:(0,r.jsx)(n.code,{children:"Era.From"})})," (optional)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/next/fundamentals/configuration#era-to",children:(0,r.jsx)(n.code,{children:"Era.To"})})," (optional)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/next/fundamentals/configuration#era-trustedaccumulatorfile",children:(0,r.jsx)(n.code,{children:"Era.TrustedAccumulatorFile"})})," (optional). If not specified, it trusts the import directory."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If both ",(0,r.jsx)(n.code,{children:"Era.From"})," and ",(0,r.jsx)(n.code,{children:"Era.To"})," are set to 0, it imports all blocks."]}),"\n",(0,r.jsxs)(n.p,{children:["Alternatively, the data can be imported using the ",(0,r.jsx)(n.a,{href:"/next/interacting/json-rpc-ns/admin#admin_importhistory",children:(0,r.jsx)(n.code,{children:"admin_importHistory"})})," JSON-RPC method. This is a non-blocking operation. However, it can be run only one at a time, making it slower than the configuration option."]}),"\n",(0,r.jsx)(n.h2,{id:"export",children:"Export"}),"\n",(0,r.jsx)(n.p,{children:"Nethermind allows exporting a block range from the database to a specified location. It can be done using the following configuration options on Nethermind startup. Note that this is a blocking operation and puts other activities on hold until it is completed:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/next/fundamentals/configuration#era-exportdirectory",children:(0,r.jsx)(n.code,{children:"Era.ExportDirectory"})})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/next/fundamentals/configuration#era-from",children:(0,r.jsx)(n.code,{children:"Era.From"})})," (optional)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/next/fundamentals/configuration#era-to",children:(0,r.jsx)(n.code,{children:"Era.To"})})," (optional)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If both ",(0,r.jsx)(n.code,{children:"Era.From"})," and ",(0,r.jsx)(n.code,{children:"Era.To"})," are set to 0, it exports all blocks. It also always creates the ",(0,r.jsx)(n.code,{children:"accumulators.txt"})," and ",(0,r.jsx)(n.code,{children:"checksums.txt"})," files."]}),"\n",(0,r.jsxs)(n.p,{children:["Alternatively, the data can be exported using the ",(0,r.jsx)(n.a,{href:"/next/interacting/json-rpc-ns/admin#admin_exporthistory",children:(0,r.jsx)(n.code,{children:"admin_exportHistory"})})," JSON-RPC method. This is a non-blocking operation. However, it can be run only one at a time, making it slower than the configuration option."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);